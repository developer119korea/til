# equals()와 hashCode() 완전 가이드

## 🤔 왜 정리하게 되었나?

최근 프로젝트에서 컬렉션을 사용하다가 예상과 다른 결과가 나오는 경우를 겪었다.
객체를 Set에 넣었는데 중복이 제거되지 않거나, HashMap에서 같은 키로 값을 찾을 수 없는 상황이 발생했다.
이런 문제들이 모두 equals()와 hashCode()와 관련이 있다는 것을 알게 되어, 체계적으로 정리해보았다.

## 📚 문서 구성

### 1. [Java equals/hashCode 기본 개념](./equals-hashcode-basic.md)

#### **Java에서의 기본적인 equals()와 hashCode() 구현과 활용**

- equals()와 hashCode()의 정의와 역할
- 계약(Contract) 조건과 함께 오버라이드해야 하는 이유
- 실제 문제 발생 사례와 해결 방법
- 올바른 구현 패턴 (수동, IDE, Lombok)
- 상속과 불변 객체에서의 고려사항
- 성능 최적화와 실무 적용 팁

**추천 대상**: Java 기본기를 다지고 싶은 개발자

### 2. [다른 언어에서의 접근 방식](./equals-hashcode-cross-language.md)

#### **Python, C#, JavaScript, Rust, Kotlin, Swift에서의 동등성 비교**

- 언어별 equals/hashCode 구현 방법
- 자동 생성 기능 비교 (dataclass, record, derive 등)
- 각 언어의 철학과 설계 차이점
- 다국어 팀에서의 고려사항
- 언어 간 마이그레이션 가이드

**추천 대상**: 다양한 언어를 사용하는 개발자, 다국어 팀

### 3. [해시 알고리즘 심화 이해](./hash-algorithm-deep-dive.md)

#### **해시 테이블의 원리와 역사적 발전 과정**

- 해시 사용 이유: O(n) → O(1)로의 혁신
- 해시 테이블 동작 원리 직접 구현
- 충돌 처리 기법 (체이닝, 개방주소법)
- 해시 함수 설계 원칙과 31의 비밀
- 역사적 발전 (1960년대~현재)
- 해시 DoS 공격과 보안 대책
- 현대 기술에서의 해시 활용

**추천 대상**: 알고리즘과 자료구조에 관심 있는 개발자

## 🎯 핵심 메시지

### 왜 equals()와 hashCode()가 중요한가?

1. **성능**: 해시 기반 컬렉션의 O(1) 성능 보장
2. **정확성**: 올바른 동등성 비교로 버그 방지
3. **호환성**: Java Collections Framework와의 완벽한 통합
4. **확장성**: 대용량 데이터 처리 시 필수

### 핵심 원칙

- **함께 구현**: equals()를 오버라이드하면 반드시 hashCode()도
- **계약 준수**: equals()가 true면 hashCode()도 동일
- **일관성 유지**: 불변 필드 기반으로 구현
- **성능 고려**: 좋은 해시 분산으로 충돌 최소화

## 🚀 실무 적용 가이드

### 빠른 체크리스트

- [ ] equals()와 hashCode()를 함께 구현했는가?
- [ ] 모든 중요한 필드를 비교에 포함했는가?
- [ ] null 안전성을 고려했는가?
- [ ] 해시코드가 고르게 분산되는가?
- [ ] 테스트 코드를 작성했는가?

### 권장 도구

- **IDE 자동 생성**: IntelliJ IDEA, Eclipse
- **Lombok**: `@EqualsAndHashCode` 어노테이션
- **테스트**: EqualsVerifier 라이브러리
- **Java 14+**: Record 클래스 활용

## 💡 마무리

equals()와 hashCode()는 단순해 보이지만 깊이 있는 주제다.
기본 개념부터 시작해서 다른 언어와의 비교, 그리고 해시 알고리즘의 역사까지
체계적으로 이해하면 더 나은 코드를 작성할 수 있을 것이다.

특히 **"왜 이렇게 설계되었을까?"**라는 질문을 통해
단순 암기가 아닌 **근본 원리의 이해**를 추구했다.

이 지식이 실무에서 더 견고하고 효율적인 코드를 작성하는 데
도움이 되길 바란다! 🎉

---
